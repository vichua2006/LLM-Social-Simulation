from typing import List
import openai

def get_embedding(text, model="text-embedding-ada-002"):
    text = text.replace("\n", " ")
    if not text: 
      text = "this is blank"
    return openai.Embedding.create(
          input=[text], model=model)['data'][0]['embedding']
    
class ConceptNode: 
  def __init__(self,
               node_id:str, node_type:str,
               created, 
               s:int, p:str, o:List[int], amount:List[float],
               description:str, embedding_key:str, poignancy): 
    self.node_id = node_id
    self.type = node_type  # chat memory/event(rob, trade, farm, obey) memory

    self.created = created
    self.last_accessed = self.created

    self.subject = s # id of the action initiator: for example, chat memory's subject is the speaker
    self.predicate = p # action itself: for example, chat memory's predicate is "chat with"
    self.object = o #ids of the action receiver: for example, chat memory's object is the listeners
    self.amount = amount #the detail about the amount in the action, for example, A rob B for "10" units of food

    self.description = description # description of the whole action: for example, "rob person one"
    self.embedding = (embedding_key, get_embedding(embedding_key)) # The key that used to generated embedding, this key is for embeddings in memory
    self.poignancy = poignancy #poignancy generated by chatGPT
    self.keywords = [s] #containing subject and object of the events for fast access and searching
    for person in o:
     self.keywords = self.keywords + person
  
  def spo_summary(self): 
    return (self.subject, self.predicate, self.object)
  
class MemoryStream:
  def __init__(self):
    self.concept_nodes = []

  def add_concept_node(self, concept_node):
    if isinstance(concept_node, ConceptNode):
      self.concept_nodes.append(concept_node)
    else:
      print("Invalid concept node. Only ConceptNode objects can be added.")

  def get_concept_node(self, index):
    if 0 <= index < len(self.concept_nodes):
      return self.concept_nodes[index]
    else:
      print("Index out of range.")

  def delete_concept_node(self, index):
    if 0 <= index < len(self.concept_nodes):
      del self.concept_nodes[index]
    else:
      print("Index out of range. Deletion failed.")

  def modify_concept_node(self, index, new_node):
    if 0 <= index < len(self.concept_nodes):
      self.concept_nodes[index] = new_node
    else:
      print("Index out of range. Modification failed.")

  def __str__(self):
    return "\n".join([f"Concept Node {i}: {node.data}" for i, node in enumerate(self.concept_nodes)])
