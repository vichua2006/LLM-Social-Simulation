from typing import List
from openai import OpenAI


def get_embedding(text, model="text-embedding-ada-002"):
    text = text.replace("\n", " ")
    if not text: 
      text = "this is blank"
    
    # updated to match current openai version
    # again, not sure how keys wanna be handled
    client = OpenAI(api_key="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")
    return client.embeddings.create(input=[text], model=model).data[0].embedding
    
class ConceptNode: 
  def __init__(self,
               node_id:int, node_type:str,
               created, 
               s:int, p:str, o:List[int], amount:float,
               description:str, poignancy): 
    self.node_id = node_id
    self.type = node_type  # chat memory/event(rob, trade, farm, obey) memory

    self.created = created
    self.last_accessed = self.created

    self.subject = s # id of the action initiator: for example, chat memory's subject is the speaker
    self.predicate = p # action itself: for example, chat memory's predicate is "chat with"
    self.object = o #ids of the action receiver: for example, chat memory's object is the listeners
    self.amount = amount #the detail about the amount in the action, for example, A rob B for "10" units of food

    self.description = description # description of the whole action: for example, "rob person one"
    self.embedding = get_embedding(description) # Generate embedding by the description
    self.poignancy = poignancy #poignancy generated by chatGPT
    self.keywords = [s] #containing subject and object of the events for fast access and searching
    for person in o:
     self.keywords.append(person)
  
  def spo_summary(self): 
    return (self.subject, self.predicate, self.object)
  
class MemoryStream:
  def __init__(self):
    self.concept_nodes = []

  def add_concept_node(self, concept_node):
    if isinstance(concept_node, ConceptNode):
      self.concept_nodes.append(concept_node)
    else:
      print("Invalid concept node. Only ConceptNode objects can be added.")

  def get_concept_node(self, index):
    if 0 <= index < len(self.concept_nodes):
      return self.concept_nodes[index]
    else:
      print("Index out of range.")
  
  def get_concept_node_by_id(self, id):
    found = False
    
    for node in self.concept_nodes:
      if node.node_id == id:
        found = True
        return node
    
    if found == False:
      print("Node id not found")
    

  def delete_concept_node(self, index):
    if 0 <= index < len(self.concept_nodes):
      del self.concept_nodes[index]
    else:
      print("Index out of range. Deletion failed.")

  def modify_concept_node(self, index, new_node):
    if 0 <= index < len(self.concept_nodes):
      self.concept_nodes[index] = new_node
    else:
      print("Index out of range. Modification failed.")

  def __str__(self):
    return "\n".join([f"Concept Node {i}: {node.spo_summary()}" for i, node in enumerate(self.concept_nodes)])
